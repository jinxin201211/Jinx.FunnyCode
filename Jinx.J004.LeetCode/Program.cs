using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Jinx.J004.LeetCode
{
    class Program
    {
        static void Main(string[] args)
        {
            #region 405. Convert a Number to Hexadecimal 35.48%
            //Console.WriteLine("Input:");
            //Int32 num_decimal;
            //num_decimal = Int32.Parse(Console.ReadLine());
            //Console.WriteLine("Output:");
            //Console.Write("\"" + _405_Convert_a_Number_to_Hexadecimal(num_decimal) + "\"");
            #endregion
            #region 221. Maximal Square
            //char[,] _221_maxtrix = { { '1', '0', '1', '0', '0' }, { '1', '0', '1', '1', '1' }, { '1', '1', '1', '1', '1' }, { '1', '0', '0', '1', '0' } };
            //_221_Maximal_Square(_221_maxtrix);
            #endregion
            #region 357. Count Numbers with Unique Digits 70.83%
            //for (int i = 0; i < 10; i++)
            //{
            //    _357_Count_Numbers_with_Unique_Digits(i);
            //}
            #endregion
            #region 412. Fizz Buzz 85.33%
            //foreach (var item in _412_Fizz_Buzz(999))
            //{
            //    Console.WriteLine(item);
            //}
            #endregion
            #region 273. Integer to English Words 42.86%
            //Console.WriteLine(_273_Integer_to_English_Words(123));
            #endregion
            #region 215. Kth Largest Element in an Array 14.29%
            //int[] temp = new int[] { -1, 2, 0 };
            //int k = 2;
            //Console.WriteLine("第{0}大的数：{1}", k, _215_Kth_Largest_Element(temp, k));
            #endregion
            #region 4. Median of Two Sorted Arrays 80.14
            //Console.WriteLine(_4_Median_of_Two_Sorted_Arrays(new int[] { 2 }, new int[] {  }));
            #endregion
            #region 1. Two Sum 28.51%
            //Console.WriteLine(_1_Two_Sum(new int[] { 2, 7, 11, 15 }, 9));
            #endregion
            #region 2. Add Two Numbers 96.90%
            //_2_Add_Two_Numbers(new ListNode(1) { next = new ListNode(2) { next = new ListNode(4) { next = new ListNode(8) } } }, new ListNode(4) { next = new ListNode(5) { next = new ListNode(6) } });
            //_2_Add_Two_Numbers(new ListNode(1) { next = new ListNode(8) }, new ListNode(0));
            #endregion
            #region 6. ZigZag Conversion 4.76%
            //Console.WriteLine(_6_ZigZag_Conversion("PAHNAPLSIIGYIRSDFEWRWETSGASDFAHSDJFKHLQWUIERYHJASFAFKHLASFAS", 4));
            #endregion
            #region 7. Reverse Integer 51.41%
            //Console.WriteLine(_7_Reverse_Integer(-2147483648));
            #endregion
            #region 11. Container With Most Water 39.13%
            //int[] array = new int[15000];
            //for (int i = 15000; i >= 1; i--)
            //{
            //    array[15000 - i] = i;
            //}
            //Console.WriteLine(_11_Container_With_Most_Water(array));
            #endregion
            #region 12. Integer to Roman 37.14%
            //for (int i = 0; i < 4000; i++)
            //{
            //    Console.WriteLine(_12_Integer_to_Roman(i));
            //}
            #endregion
            #region 13. Roman to Integer 75.41%
            //for (int i = 1; i < 4000; i++)
            //{
            //    Console.WriteLine(_13_Roman_to_Integer(_12_Integer_to_Roman(i)));
            //}
            #endregion
            #region 14. Longest Common Prefix 23.44%
            //Console.WriteLine(_14_Longest_Common_Prefix(new string[] { "string", "str1", "str54556", "stri34qw", "string564as" }));
            //Console.WriteLine(_14_Longest_Common_Prefix(new string[] { }));
            //Console.WriteLine(_14_Longest_Common_Prefix(new string[] { "aa", "a" }));
            #endregion
            #region 15. 3Sum
            //foreach (var item in _15_3Sum(new int[] { -1, 0, 1, 2, -1, -4 }))
            //{
            //    foreach (var item2 in item)
            //    {
            //        Console.Write(item2 + " ");
            //    }
            //    Console.WriteLine();
            //}
            #endregion
            #region 17. Letter Combinations of a Phone Number 53.80%
            //foreach (var item in _17_Letter_Combinations_of_a_Phone_Number(""))
            //{
            //    Console.WriteLine(item);
            //}
            #endregion
            #region 19. Remove Nth Node From End of List 88.14%
            //ListNode result = _19_Remove_Nth_Node_From_End_of_List(new ListNode(1) { next = new ListNode(2) { next = new ListNode(3) { next = new ListNode(4) { next = new ListNode(5) } } } }, 2);
            //ListNode result = _19_Remove_Nth_Node_From_End_of_List(new ListNode(1), 1);
            //ListNode result = _19_Remove_Nth_Node_From_End_of_List(new ListNode(1) { next = new ListNode(2)}, 2);
            //while (result != null)
            //{
            //    Console.WriteLine(result.val);
            //    result = result.next;
            //}
            #endregion
            #region 20. Valid Parentheses 87.23%
            //Console.WriteLine(_20_Valid_Parentheses("(])"));
            #endregion
            #region 21. Merge Two Sorted Lists 44.00%
            //ListNode result = _21_Merge_Two_Sorted_Lists(new ListNode(1) { next = new ListNode(3) { next = new ListNode(5) { next = new ListNode(7) { next = new ListNode(9) } } } }, new ListNode(2) { next = new ListNode(4) { next = new ListNode(6) { next = new ListNode(8) { next = new ListNode(10) } } } });
            //ListNode result = _21_Merge_Two_Sorted_Lists(new ListNode(1) , null);
            //while (result != null)
            //{
            //    Console.WriteLine(result.val);
            //    result = result.next;
            //}
            #endregion
            #region 26. Remove Duplicates from Sorted Array 64.35%
            //Console.WriteLine(_26_Remove_Duplicates_from_Sorted_Array(new int[] { 1, 1, 2, 3, 4, 5, 5, 5, 6, 7, 8, 8, 8, 9, 9, 9 }));
            #endregion
            #region 27. Remove Element 77.44%
            //Console.WriteLine(_27_Remove_Element(new int[] { 3, 2, 3, 2, 1 }, 3));
            #endregion
            #region 28. Implement strStr() 53.11%
            //Console.WriteLine(_28_Implement_strStr("abcabaabcaabac", "abaa"));
            //Console.WriteLine(_28_Implement_strStr("abcabaabcaabac", ""));
            //Console.WriteLine(_28_Implement_strStr("", "abaa"));
            //Console.WriteLine(_28_Implement_strStr("", ""));
            //Console.WriteLine(_28_Implement_strStr("abcabaabcaabac", "ab"));
            //Console.WriteLine(_28_Implement_strStr("aaaa", "a"));
            //Console.WriteLine(_28_Implement_strStr("a", "a"));
            //Console.WriteLine(_28_Implement_strStr("mississippi", "issip"));
            #endregion
            #region 29. Divide Two Integers
            //Console.WriteLine(_29_Divide_Two_Integers(100, 9));
            //Console.WriteLine(_29_Divide_Two_Integers(-1, 1));
            //Console.WriteLine(_29_Divide_Two_Integers(-1, -1));
            //Console.WriteLine(_29_Divide_Two_Integers(-1, -3));
            //Console.WriteLine(_29_Divide_Two_Integers(int.MinValue, -1));
            #endregion
            #region 461. Hamming Distance 72.97%
            //Console.WriteLine(_461_Hamming_Distance(1, 4));
            #endregion
            #region 344. Reverse String 90.21%
            //Console.WriteLine(_344_Reverse_String("Hello World!!"));
            #endregion
            #region 463. Island Perimeter 79.82%
            //Console.WriteLine(_463_Island_Perimeter(new int[,] { { 0, 1, 0, 0 }, { 1, 1, 1, 0 }, { 0, 1, 0, 0 }, { 1, 1, 0, 0 } }));
            #endregion
            #region 448. Find All Numbers Disappeared in an Array 66.45%
            //foreach (var item in _448_Find_All_Numbers_Disappeared_in_an_Array(new int[] { 4, 3, 2, 7, 8, 2, 3, 1 }))
            //{
            //    Console.WriteLine(item);
            //}
            #endregion
            #region 136. Single Number 55.60%
            //Console.WriteLine(_136_Single_Number(new int[] { 1, 2, 3, 4, 5, 6, 1, 2, 4, 5, 6 }));
            //Console.WriteLine(_136_Single_Number(new int[] { 1 }));
            #endregion
            #region 104. Maximum Depth of Binary Tree 41.15%
            //Console.WriteLine(_104_Maximum_Depth_of_Binary_Tree(new TreeNode(1) { left = new TreeNode(2) { left = new TreeNode(3), right = new TreeNode(6) }, right = new TreeNode(4) { left = new TreeNode(5), right = new TreeNode(7) } }));
            //Console.WriteLine(_104_Maximum_Depth_of_Binary_Tree(new TreeNode(1) { right = new TreeNode(4) { right = new TreeNode(7) } }));
            #endregion
            #region 258. Add Digits 78.21%
            //Console.WriteLine(_258_Add_Digits(123456789));
            #endregion
            #region 226. Invert Binary Tree 89.13%
            //var result = _226_Invert_Binary_Tree(new TreeNode(1) { left = new TreeNode(2) { left = new TreeNode(4), right = new TreeNode(5) }, right = new TreeNode(3) { left = new TreeNode(6), right = new TreeNode(7) } });
            #endregion
            #region 283. Move Zeroes 64.36%
            //_283_Move_Zeroes(new int[] { 0, 1, 0, 3, 12 });
            #endregion
            #region 349. Intersection of Two Arrays 78.34%
            //foreach (var item in _349_Intersection_of_Two_Arrays(new int[] { 1, 2, 2, 3, 3, 4 }, new int[] { 2, 2 }))
            //{
            //    Console.WriteLine(item);
            //}
            #endregion
            #region 404. Sum of Left Leaves 81.82%
            //var result = _404_Sum_of_Left_Leaves(new TreeNode(1) { left = new TreeNode(2) { left = new TreeNode(4), right = new TreeNode(5) }, right = new TreeNode(3) { left = new TreeNode(6), right = new TreeNode(7) } });
            #endregion
            #region 237. Delete Node in a Linked List 19.21%
            //ListNode node = new ListNode(1) { next = new ListNode(2) { next = new ListNode(3) { next = new ListNode(4) } } };
            //_237_Delete_Node_in_a_Linked_List(node);
            //Console.WriteLine(node);
            #endregion
            #region 387. First Unique Character in a String
            //Console.WriteLine(_387_First_Unique_Character_in_a_String("1234567898"));
            #endregion
            #region 168. Excel Sheet Column Title 92.04%
            //Console.WriteLine(_168_Excel_Sheet_Column_Title(52));
            #endregion
            #region 100. Same Tree 62.30%
            //Console.WriteLine(_100_Same_Tree(new TreeNode(1) { left = new TreeNode(2) { left = new TreeNode(4), right = new TreeNode(5) }, right = new TreeNode(3) { left = new TreeNode(6), right = new TreeNode(7) } }, new TreeNode(1) { left = new TreeNode(2) { left = new TreeNode(4), right = new TreeNode(5) }, right = new TreeNode(3) { left = new TreeNode(6), right = new TreeNode(7) } }));
            //Console.WriteLine(_100_Same_Tree(new TreeNode(1) { left = new TreeNode(2) { left = new TreeNode(4), right = new TreeNode(5) }, right = new TreeNode(3) { left = new TreeNode(6), right = new TreeNode(7) } }, new TreeNode(1) { left = new TreeNode(2) { left = new TreeNode(4) { left = new TreeNode(5) { left = new TreeNode(3) { left = new TreeNode(6) { left = new TreeNode(7) } } } } } }));
            //Console.WriteLine(_100_Same_Tree(new TreeNode(1) { left = new TreeNode(2) }, new TreeNode(1) { right = new TreeNode(2) }));
            #endregion
            #region 171. Excel Sheet Column Number 57.25%
            //Console.WriteLine(_171_Excel_Sheet_Column_Number("ZZ"));
            #endregion
            #region 206. Reverse Linked List 75.98%
            //var result = _206_Reverse_Linked_List(new ListNode(1) { next = new ListNode(2) { next = new ListNode(3) { next = new ListNode(4) { next = new ListNode(5) { next = new ListNode(6) { next = new ListNode(7) { next = new ListNode(8) } } } } } } });
            //while (result != null)
            //{
            //    Console.WriteLine(result.val);
            //    result = result.next;
            //}
            #endregion
            #region 415. Add Strings 11.76%
            //Console.WriteLine(_415_Add_Strings("1110", "2100"));
            #endregion
            #region 326. Power of Three 43.54%
            //Console.WriteLine(_326_Power_of_Three(729));
            #endregion
            #region 121. Best Time to Buy and Sell Stock
            //int[] nums = new int[10000];
            //for (int i = 10000; i > 0; i--)
            //{
            //    nums[10000 - i] = i;
            //}
            //Console.WriteLine(_121_Best_Time_to_Buy_and_Sell_Stock(nums));
            //Console.WriteLine(_121_Best_Time_to_Buy_and_Sell_Stock(new int[] { 2, 4, 1 }));
            #endregion
            #region 83. Remove Duplicates from Sorted List 49.12%
            //var result = _83_Remove_Duplicates_from_Sorted_List(new ListNode(1) { next = new ListNode(1) { next = new ListNode(2) { next = new ListNode(2) { next = new ListNode(2) { next = new ListNode(3) { next = new ListNode(3) { } } } } } } });
            //while (result != null)
            //{
            //    Console.WriteLine(result.val);
            //    result = result.next;
            //}
            #endregion
            #region 231. Power of Two 71.63%
            //for (int i = 1; i <= 1024; i++)
            //{
            //    Console.WriteLine(i + ":" + _231_Power_of_Two(i));
            //}
            #endregion
            #region 70. Climbing Stairs
            //for (int i = 0; i < 10; i++)
            //{
            //    Console.WriteLine(_70_Climbing_Stairs(i));
            //}
            //Console.WriteLine(_70_Climbing_Stairs(44));
            #endregion
            #region 191. Number of 1 Bits 37.89%
            //Console.WriteLine(_191_Number_of_1_Bits(11));
            #endregion
            #region 263. Ugly Number 42.55%
            //Console.WriteLine(_263_Ugly_Number(7));
            //Console.WriteLine(_263_Ugly_Number(30));
            //Console.WriteLine(_263_Ugly_Number(-7));
            //Console.WriteLine(_263_Ugly_Number(-30));
            //Console.WriteLine(_263_Ugly_Number(2));
            #endregion
            #region 235. Lowest Common Ancestor of a Binary Search Tree 13.24%
            //Console.WriteLine(_235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree(new TreeNode(6) { left = new TreeNode(2) { left = new TreeNode(0), right = new TreeNode(4) { left = new TreeNode(3), right = new TreeNode(5) } }, right = new TreeNode(8) { left = new TreeNode(7), right = new TreeNode(9) } }, new TreeNode(2), new TreeNode(8)).val);
            //Console.WriteLine(_235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree(new TreeNode(2) { left = new TreeNode(1) }, new TreeNode(2), new TreeNode(1)).val);
            #endregion
            #region 434. Number of Segments in a String 57.48%
            //Console.WriteLine(_434_Number_of_Segments_in_a_String("Hello, my name is John"));
            #endregion
            #region 107. Binary Tree Level Order Traversal II 10.00%
            //foreach (var item1 in _107_Binary_Tree_Level_Order_Traversal_II(new TreeNode(1) { left = new TreeNode(2) { left = new TreeNode(4) { left = new TreeNode(6), right = new TreeNode(7) }, right = new TreeNode(5) }, right = new TreeNode(3) }))
            //{
            //    foreach (var item in item1)
            //    {
            //        Console.Write(item + "\t");
            //    }
            //    Console.WriteLine();
            //}
            #endregion
            #region 342. Power of Four 79.31%
            //Console.WriteLine(_342_Power_of_Four(16));
            #endregion
            #region 345. Reverse Vowels of a String 66.93%
            //Console.WriteLine(_345_Reverse_Vowels_of_a_String("hello"));
            #endregion
            #region 24. Swap Nodes in Pairs 30.11%
            //var result = _24_Swap_Nodes_in_Pairs(new ListNode(1) { next = new ListNode(2) { next = new ListNode(3) { next = new ListNode(4) { next = new ListNode(5) { next = new ListNode(6) { next = new ListNode(7) { next = new ListNode(8) { next = new ListNode(9) { next = new ListNode(10) { next = new ListNode(11) } } } } } } } } } });
            //while (result != null)
            //{
            //    Console.WriteLine(result.val);
            //    result = result.next;
            //}
            //var result = _24_Swap_Nodes_in_Pairs(new ListNode(1));
            //while (result != null)
            //{
            //    Console.WriteLine(result.val);
            //    result = result.next;
            //}
            #endregion
            #region 102. Binary Tree Level Order Traversal 94.97%
            //foreach (var item1 in _102_Binary_Tree_Level_Order_Traversal(new TreeNode(1) { left = new TreeNode(2) { left = new TreeNode(4) { left = new TreeNode(6), right = new TreeNode(7) }, right = new TreeNode(5) }, right = new TreeNode(3) }))
            //{
            //    foreach (var item in item1)
            //    {
            //        Console.Write(item + "\t");
            //    }
            //    Console.WriteLine();
            //}
            #endregion
            #region 66. Plus One 71.22%
            //foreach (var item in _66_Plus_One(new int[] { 1, 0 }))
            //{
            //    Console.Write(item);
            //}
            #endregion
            #region 118. Pascal's Triangle 35.62%
            //foreach (var item1 in _118_Pascal_s_Triangle(15))
            //{
            //    foreach (var item in item1)
            //    {
            //        Console.Write(item + "\t");
            //    }
            //    Console.WriteLine();
            //}
            #endregion
            #region 441. Arranging Coins 31.03%
            //Console.WriteLine(_441_Arranging_Coins(2));
            #endregion
            #region 141. Linked List Cycle
            //ListNode node1 = new ListNode(1), node2 = new ListNode(2), node3 = new ListNode(3), node4 = new ListNode(4);
            //node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node2;

            //Console.WriteLine(_141_Linked_List_Cycle(node1));
            //List<ListNode> nodes = new List<ListNode>();
            //Console.WriteLine();
            //bool same = false;
            //while (node1 != null && !same)
            //{
            //    Console.Write(node1.val);
            //    same = false;
            //    foreach (var item in nodes)
            //    {
            //        if (item == node1)
            //        {
            //            same = true;
            //            break;
            //        }
            //    }
            //    nodes.Add(node1);
            //    node1 = node1.next;
            //    if (same == true)
            //        break;
            //    System.Threading.Thread.Sleep(333);
            //}
            #endregion
            #region 119. Pascal's Triangle II 39.71%
            //foreach (var item in _119_Pascal_s_Triangle_II(5))
            //{
            //    Console.Write(item + "\t");
            //}
            //Console.WriteLine();
            #endregion
            #region 172. Factorial Trailing Zeroes 11.67%
            //Console.WriteLine(_172_Factorial_Trailing_Zeroes(1236400000));
            #endregion
            #region 257. Binary Tree Paths 38.79%
            //foreach (var item in _257_Binary_Tree_Paths(new TreeNode(1) { left = new TreeNode(2) { right = new TreeNode(4) }, right = new TreeNode(3) }))
            //{
            //    Console.WriteLine(item);
            //}
            #endregion
            #region 299. Bulls and Cows 45.61%
            //Console.WriteLine(_299_Bulls_and_Cows("1807", "7810"));
            #endregion
            #region 112. Path Sum 7.89%
            //Console.WriteLine(_112_Path_Sum(new TreeNode(1) { left = new TreeNode(2) { right = new TreeNode(4) }, right = new TreeNode(3) }, 4));
            #endregion
            #region 205. Isomorphic Strings 55.26%
            //Console.WriteLine(_205_Isomorphic_Strings("egg", "abc"));
            #endregion
            #region 111. Minimum Depth of Binary Tree 3.06%
            //Console.WriteLine(_111_Minimum_Depth_of_Binary_Tree(new TreeNode(1) { left = new TreeNode(2) { left = new TreeNode(3), right = new TreeNode(6) }, right = new TreeNode(4) { left = new TreeNode(5), right = new TreeNode(7) } }));
            //Console.WriteLine(_111_Minimum_Depth_of_Binary_Tree(new TreeNode(1) { right = new TreeNode(4) { right = new TreeNode(7) } }));
            #endregion
            #region 223. Rectangle Area 54.84%
            //Console.WriteLine(_223_Rectangle_Area(-2, -2, 2, 2, 3, 3, 4, 4));
            #endregion
            #region 234. Palindrome Linked List 32.81%
            //Console.WriteLine(_234_Palindrome_Linked_List(new ListNode(1) { next = new ListNode(1) { next = new ListNode(2)} }));
            #endregion
            #region 219. Contains Duplicate II
            //int[] nums = new int[54500];
            //for (int i = -24500; i < 30000; i++)
            //{
            //    nums[i + 24500] = i;
            //}
            //Console.WriteLine(_219_Contains_Duplicate_II(nums, 35000));
            #endregion
            #region 88. Merge Sorted Array 10.86%
            //_88_Merge_Sorted_Array(new int[] { 1, 2, 3, 0, 0, 0 }, 3, new int[] { 2, 5, 6 }, 3);
            #endregion
            #region 58. Length of Last Word 58.67%
            //Console.WriteLine(_58_Length_of_Last_Word("Hello World!!!"));
            #endregion
            #region 203. Remove Linked List Elements 41.23%
            //var result = _203_Remove_Linked_List_Elements(new ListNode(1) { next = new ListNode(2) { next = new ListNode(6) { next = new ListNode(3) { next = new ListNode(4) { next = new ListNode(5) { next = new ListNode(6) { next = new ListNode(7) { } } } } } } } }, 6);
            //var result = _203_Remove_Linked_List_Elements(new ListNode(1) { next = new ListNode(1) }, 1);
            //while (result != null)
            //{
            //    Console.WriteLine(result.val);
            //    result = result.next;
            //}
            #endregion
            #region 67. Add Binary 88.33%
            //Console.WriteLine(_67_Add_Binary("1111", "1111"));
            #endregion
            #region 396. Rotate Function
            //Console.WriteLine(_396_Rotate_Function(new int[] { -2147483648, -2147483648 }));
            #endregion
            #region 400. Nth Digit
            //for (int i = 0; i < 190; i++)
            //Console.Write(_400_Nth_Digit(i) + "\t");
            #endregion
            #region 475. Heaters
            //Console.WriteLine(_475_Heaters(new int[] { 4, 8 }, new int[] { 7 }));
            #endregion
            #region 160. Intersection of Two Linked Lists 57.27%
            //Console.WriteLine(_160_Intersection_of_Two_Linked_Lists(new ListNode(1) { next = new ListNode(2) { next = new ListNode(3) { next = new ListNode(4) { next = new ListNode(5) { next = new ListNode(6) { next = new ListNode(7) { next = new ListNode(8) { next = new ListNode(9) { next = new ListNode(10) { } } } } } } } } } }, new ListNode(4) { next = new ListNode(5) { next = new ListNode(6) { next = new ListNode(7) { next = new ListNode(8) { next = new ListNode(9) { next = new ListNode(10) } } } } } }).val);
            #endregion
            #region 190. Reverse Bits 65.48%
            //Console.WriteLine(_190_Reverse_Bits(43261596));
            #endregion
            #region 414. Third Maximum Number 40.87%
            //Console.WriteLine(_414_Third_Maximum_Number(new int[] { 1, 2, 2 }));
            #endregion
            #region 204. Count Primes
            //Console.WriteLine(_204_Count_Primes(1500000));
            #endregion
            #region 125. Valid Palindrome 96.92%
            //Console.WriteLine(_125_Valid_Palindrome("aA"));
            #endregion
            #region 189. Rotate Array 43.00%
            //_189_Rotate_Array(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 }, 5);
            #endregion
            #region 165. Compare Version Numbers 57.69%
            //Console.WriteLine(_165_Compare_Version_Numbers("1", "1.0"));
            #endregion
            #region 338. Counting Bits 71.43%
            //foreach (var item in _338_Counting_Bits(20))
            //{
            //    Console.WriteLine(item);
            //}
            #endregion
            #region 260. Single Number III 84.75%
            //foreach (var item in _260_Single_Number_III(new int[] { -1, 1, 2, 3, 1, 2, 5 }))
            //{
            //    Console.WriteLine(item);
            //}
            #endregion
            #region 442. Find All Duplicates in an Array 80.67%
            //foreach (var item in _442_Find_All_Duplicates_in_an_Array(new int[] { 4, 3, 2, 7, 8, 2, 3, 1 }))
            //{
            //    Console.WriteLine(item);
            //}
            #endregion
            #region 150. Evaluate Reverse Polish Notation 49.28%
            //Console.WriteLine(_150_Evaluate_Reverse_Polish_Notation(new string[] { "0", "3", "/" }));
            #endregion
            #region 43. Multiply Strings 22.11%
            //_43_Multiply_Strings("140", "721");
            #endregion
            #region 50. Pow(x, n) 14.45%
            //Console.WriteLine(_50_Pow_x_n(2.0000000, -2147483648));
            #endregion
            #region 60. Permutation Sequence 18.33%
            //Console.WriteLine(_60_Permutation_Sequence(4, 2));
            #endregion
            #region 148. Sort List
            var result = _148_Sort_List(new ListNode(5) { next = new ListNode(3) { next = new ListNode(2) { next = new ListNode(4) { next = new ListNode(1) { next = new ListNode(7) { next = new ListNode(9) { next = new ListNode(0) { next = new ListNode(13) { next = new ListNode(11) { next = new ListNode(10) { next = new ListNode(11) } } } } } } } } } } });
            while (result != null)
            {
                Console.WriteLine(result.val);
                result = result.next;
            }
            #endregion
        }
        #region 完成
        public static string _405_Convert_a_Number_to_Hexadecimal(Int32 num)
        {
            //return Convert.ToString(num, 16);

            string result = string.Empty;
            Int32 shang = num > 0 ? num : -num, yushu = 0;
            int[] results = new int[8] { 0, 0, 0, 0, 0, 0, 0, 0 };
            int i = 0;

            if (num == -2147483648)
                return "80000000";

            //每一位的十进制数
            do
            {
                yushu = shang % 16;
                results[i++] = yushu;

                //result = yushu + result;
                shang = shang / 16;
            } while (shang != 0);

            //负数的情况
            if (num < 0)
            {
                for (int j = 7; j >= 0; j--)
                {
                    results[j] = 15 - results[j];
                }
                results[0]++;
                for (int j = 0; j < 7 && results[j] == 16; j++)
                {
                    results[j] = 0;
                    results[j + 1]++;
                }
                for (int j = 7; j >= 0; j--)
                {
                    switch (results[j])
                    {
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9: result += results[j]; break;
                        case 10: result += "a"; break;
                        case 11: result += "b"; break;
                        case 12: result += "c"; break;
                        case 13: result += "d"; break;
                        case 14: result += "e"; break;
                        case 15: result += "f"; break;
                        default:
                            break;
                    }
                }
            }
            else
            {
                for (int j = i - 1; j >= 0; j--)
                {
                    switch (results[j])
                    {
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9: result += results[j]; break;
                        case 10: result += "a"; break;
                        case 11: result += "b"; break;
                        case 12: result += "c"; break;
                        case 13: result += "d"; break;
                        case 14: result += "e"; break;
                        case 15: result += "f"; break;
                        default:
                            break;
                    }
                }
            }
            return result;
        }
        public static int _221_Maximal_Square(char[,] matrix)
        {
            int maxlength = 0;
            int matrix_width = matrix.GetLength(1), matrix_height = matrix.GetLength(0);//横、纵
            for (int i = 0; i < matrix_height * matrix_width; i++)
            {
                int x = i / matrix_width, y = i % matrix_width;//纵、横
                int length = 0;
                //if (matrix[x, y] == '0')
                //    continue;

                for (int j = 1; j < matrix_width - y && j < matrix_height - x; j++)
                {
                    length = j;
                    int temp_area = 0;
                    for (int m = 0; m < j; m++)
                    {
                        for (int n = 0; n < j; n++)
                        {
                            temp_area += Convert.ToInt16(matrix[m, n]);
                        }
                    }
                    if (temp_area == j * j)
                    {
                        length = j;
                    }
                    else
                        break;
                }

                if (length > maxlength)
                    maxlength = length;

                Console.Write(matrix[x, y] + " ");
                if (y == matrix_width - 1)
                    Console.WriteLine();
            }

            Console.WriteLine(maxlength);

            return maxlength;
        }
        public static int _357_Count_Numbers_with_Unique_Digits(int n)
        {
            int count = 0;
            for (int i = 0; i <= n; i++)
            {
                int num = 0;
                if (i == 0)
                {
                    num = 1;
                }
                else
                {
                    num = 9;
                    for (int j = i - 1; j > 0; j--)
                        num *= (10 - j);
                }
                count += num;
            }

            Console.WriteLine(count);
            return count;
        }
        public static IList<string> _412_Fizz_Buzz(int n)
        {
            string[] result = new string[n];

            for (int i = 1; i <= n; i++)
            {
                if (i % 3 == 0 && i % 5 == 0)
                {
                    result[i - 1] = "FizzBuzz";
                }
                else if (i % 3 == 0)
                {
                    result[i - 1] = "Fizz";
                }
                else if (i % 5 == 0)
                {
                    result[i - 1] = "Buzz";
                }
                else
                {
                    result[i - 1] = i.ToString();
                }
            }

            return result;
        }
        public static string _273_Integer_to_English_Words(int num)
        {
            if (num == 0)
                return "Zero";
            string result = string.Empty;

            string str_num = num.ToString();
            if (str_num.Length % 3 == 1)
                str_num = "00" + str_num;
            else if (str_num.Length % 3 == 2)
                str_num = "0" + str_num;

            for (int i = 1; i <= str_num.Length / 3; i++)
            {
                int group_num = int.Parse(str_num.Substring(str_num.Length - 3 * i, 3));
                string group_bai = string.Empty, group_shi = string.Empty, group_ge = string.Empty;

                switch (group_num / 100)
                {
                    case 0: break;
                    case 1: group_bai = "One Hundred"; break;
                    case 2: group_bai = "Two Hundred"; break;
                    case 3: group_bai = "Three Hundred"; break;
                    case 4: group_bai = "Four Hundred"; break;
                    case 5: group_bai = "Five Hundred"; break;
                    case 6: group_bai = "Six Hundred"; break;
                    case 7: group_bai = "Seven Hundred"; break;
                    case 8: group_bai = "Eight Hundred"; break;
                    case 9: group_bai = "Nine Hundred"; break;
                }
                if (group_num % 100 / 10 == 1)
                {
                    group_shi = string.Empty;
                    switch (group_num % 10)
                    {
                        case 0: group_ge = "Ten"; break;
                        case 1: group_ge = "Eleven"; break;
                        case 2: group_ge = "Twelve"; break;
                        case 3: group_ge = "Thirteen"; break;
                        case 4: group_ge = "Fourteen"; break;
                        case 5: group_ge = "Fifteen"; break;
                        case 6: group_ge = "Sixteen"; break;
                        case 7: group_ge = "Seventeen"; break;
                        case 8: group_ge = "Eighteen"; break;
                        case 9: group_ge = "Nineteen"; break;
                    }
                }
                else
                {
                    switch (group_num % 100 / 10)
                    {
                        case 0: break;
                        case 2: group_shi = "Twenty"; break;
                        case 3: group_shi = "Thirty"; break;
                        case 4: group_shi = "Forty"; break;
                        case 5: group_shi = "Fifty"; break;
                        case 6: group_shi = "Sixty"; break;
                        case 7: group_shi = "Seventy"; break;
                        case 8: group_shi = "Eighty"; break;
                        case 9: group_shi = "Ninety"; break;
                    }
                    switch (group_num % 10)
                    {
                        case 0: break;
                        case 1: group_ge = "One"; break;
                        case 2: group_ge = "Two"; break;
                        case 3: group_ge = "Three"; break;
                        case 4: group_ge = "Four"; break;
                        case 5: group_ge = "Five"; break;
                        case 6: group_ge = "Six"; break;
                        case 7: group_ge = "Seven"; break;
                        case 8: group_ge = "Eight"; break;
                        case 9: group_ge = "Nine"; break;
                    }
                }

                if (group_bai.Length == 0 && group_shi.Length == 0 && group_ge.Length == 0)
                    continue;
                if (i == 1)
                {
                    result = group_bai + " " + group_shi + " " + group_ge + " ";
                }
                else if (i == 2)
                {
                    result = group_bai + " " + group_shi + " " + group_ge + " Thousand " + result;
                }
                else if (i == 3)
                {
                    result = group_bai + " " + group_shi + " " + group_ge + " Million " + result;
                }
                else if (i == 4)
                {
                    result = group_bai + " " + group_shi + " " + group_ge + " Billion " + result;
                }
            }

            StringBuilder sb = new StringBuilder();
            foreach (var item in result.Split(' '))
            {
                if (item.Trim().Length != 0)
                    sb.Append(item).Append(" ");
            }

            return sb.ToString().Trim();
        }
        public static int _215_Kth_Largest_Element(int[] nums, int k)
        {
            if (k < 1 || k > nums.Length)
                return 0;

            for (int i = 0; i < k; i++)
            {
                int maxindex = i;
                for (int j = i + 1; j < nums.Length; j++)
                {
                    if (nums[j] > nums[maxindex])
                        maxindex = j;
                }
                if (maxindex != i)
                {
                    int temp = nums[maxindex];
                    nums[maxindex] = nums[i];
                    nums[i] = temp;
                }
            }

            return nums[k - 1];
        }
        public static double _4_Median_of_Two_Sorted_Arrays(int[] nums1, int[] nums2)
        {
            int length1 = nums1.Length, length2 = nums2.Length;

            if ((length1 + length2) % 2 == 1)
            {
                int index1 = 0, index2 = 0, indexmid = 0, midnum = 0;

                while (indexmid < (length1 + length2) / 2 + 1)
                {
                    if (index1 >= length1)
                    {
                        midnum = nums2[index2];
                        index2++;
                    }
                    else if (index2 >= length2)
                    {
                        midnum = nums1[index1];
                        index1++;
                    }
                    else if (nums1[index1] < nums2[index2])
                    {
                        midnum = nums1[index1];
                        index1++;
                    }
                    else
                    {
                        midnum = nums2[index2];
                        index2++;
                    }
                    indexmid++;
                }

                return midnum;
            }
            else
            {
                int index1 = 0, index2 = 0, indexmid1 = 0, indexmid2 = 0, midnum1 = 0, midnum2 = 0;

                while (indexmid1 < (length1 + length2) / 2 || indexmid2 < (length1 + length2) / 2 + 1)
                {
                    if (index1 >= length1)
                    {
                        if (indexmid1 < (length1 + length2) / 2)
                            midnum1 = nums2[index2];
                        midnum2 = nums2[index2];
                        index2++;
                    }
                    else if (index2 >= length2)
                    {
                        if (indexmid1 < (length1 + length2) / 2)
                            midnum1 = nums1[index1];
                        midnum2 = nums1[index1];
                        index1++;
                    }
                    else if (nums1[index1] < nums2[index2])
                    {
                        if (indexmid1 < (length1 + length2) / 2)
                            midnum1 = nums1[index1];
                        midnum2 = nums1[index1];
                        index1++;
                    }
                    else
                    {
                        if (indexmid1 < (length1 + length2) / 2)
                            midnum1 = nums2[index2];
                        midnum2 = nums2[index2];
                        index2++;
                    }
                    indexmid1++;
                    indexmid2++;
                }

                return (midnum1 + midnum2) / 2.0;
            }

        }
        public static int[] _1_Two_Sum(int[] nums, int target)
        {
            int num1 = 0, num2 = 0;
            for (int i = 0; i < nums.Length; i++)
            {
                num1 = i;
                for (int j = i + 1; j < nums.Length; j++)
                {
                    num2 = j;
                    if (nums[num1] + nums[num2] == target)
                        return new int[] { num1, num2 };
                }
            }

            return new int[] { num1, num2 };
        }
        public static ListNode _2_Add_Two_Numbers(ListNode l1, ListNode l2)
        {
            ListNode result = new ListNode(0);
            ListNode temp = result;
            int carry = 0;
            while (l1 != null || l2 != null || carry == 1)
            {
                if (l1 != null && l2 != null)
                {
                    temp.val = l1.val + l2.val + carry >= 10 ? l1.val + l2.val - 10 + carry : l1.val + l2.val + carry;
                    carry = l1.val + l2.val + carry >= 10 ? 1 : 0;
                    l1 = l1.next;
                    l2 = l2.next;
                }
                else if (l1 != null)
                {
                    temp.val = l1.val + carry >= 10 ? l1.val - 10 + carry : l1.val + carry;
                    carry = l1.val + carry >= 10 ? 1 : 0;
                    l1 = l1.next;
                }
                else if (l2 != null)
                {
                    temp.val = l2.val + carry >= 10 ? l2.val - 10 + carry : l2.val + carry;
                    carry = l2.val + carry >= 10 ? 1 : 0;
                    l2 = l2.next;
                }
                else
                {
                    temp.val = carry;
                    carry = 0;
                }
                if (l1 != null || l2 != null || carry == 1)
                {
                    temp.next = new ListNode(0);
                    temp = temp.next;
                }
            }
            temp = result;
            while (temp != null)
            {
                Console.WriteLine(temp.val + "->");
                temp = temp.next;
            }

            return result;
        }
        public static string _6_ZigZag_Conversion(string s, int numRows)
        {
            char[,] strZigzag = new char[numRows, s.Length];

            for (int i = 0, j = 0; i < s.Length; )
            {
                int k = 0;
                for (k = 0; k < numRows && i < s.Length; k++)
                {
                    strZigzag[k, j] = s[i];
                    i++;

                    Console.Clear();
                    for (int m = 0; m < numRows; m++)
                    {
                        for (int n = 0; n < s.Length; n++)
                        {
                            Console.Write(strZigzag[m, n] + " ");
                        }
                        Console.WriteLine();
                    }
                    System.Threading.Thread.Sleep(50);
                }
                for (k = j + 1; k - j < numRows - 1 && i < s.Length; k++, i++)
                {
                    strZigzag[numRows - k + j - 1, k] = s[i];
                    Console.Clear();
                    for (int m = 0; m < numRows; m++)
                    {
                        for (int n = 0; n < s.Length; n++)
                        {
                            Console.Write(strZigzag[m, n] + " ");
                        }
                        Console.WriteLine();
                    }
                    System.Threading.Thread.Sleep(50);
                }
                j = k;
            }

            string result = string.Empty;
            for (int i = 0; i < numRows; i++)
            {
                for (int j = 0; j < s.Length; j++)
                {
                    if (strZigzag[i, j] != '\0')
                        result += strZigzag[i, j];
                }
            }

            return result;
        }
        public static int _7_Reverse_Integer(int x)
        {
            //long y = x.ToString().Contains("-") ? long.Parse(x.ToString().Replace("-", "")) : x;
            long y = x < 0 ? -x : x;
            if (x == int.MinValue)
                y = (long)int.MaxValue + 1;
            int length = 0;
            int[] num = new int[100];
            while (y != 0)
            {
                num[length++] = (int)(y % 10);
                y = y / 10;
            }

            long multi = 1;
            long result = 0;
            for (int i = length - 1; i >= 0; i--)
            {
                result += num[i] * multi;
                multi *= 10;
            }
            if (result > int.MaxValue)
                return 0;
            else
                return (int)(x < 0 ? -result : result);
        }
        public static int _11_Container_With_Most_Water(int[] height)
        {
            int L = height.Length, lo = 0, hi = L - 1;
            int max = 0;
            while (lo < hi)
            {
                int loMax = height[lo], hiMax = height[hi];

                int candidate = (hi - lo) * (loMax < hiMax ? loMax : hiMax);
                max = candidate > max ? candidate : max;

                if (height[lo] <= height[hi])
                    while (lo < hi && height[lo] <= loMax) ++lo;
                else
                    while (hi > lo && height[hi] <= hiMax) --hi;
            }
            return max;
        }
        public static string _12_Integer_to_Roman(int num)
        {
            if (num > 3999)
                return "";
            StringBuilder result = new StringBuilder();
            int qian = num / 1000, bai = num % 1000 / 100, shi = num % 100 / 10, ge = num % 10;
            while (qian > 0)
            {
                result.Append('M');
                qian--;
            }
            if (bai >= 4)
            {
                if (bai == 4)
                {
                    result.Append("CD");
                    bai = 0;
                }
                else if (bai == 9)
                {
                    result.Append("CM");
                    bai = 0;
                }
                else
                {
                    result.Append('D');
                    bai -= 5;
                }
            }
            while (bai > 0)
            {
                result.Append('C');
                bai--;
            }

            if (shi >= 4)
            {
                if (shi == 4)
                {
                    result.Append("XL");
                    shi = 0;
                }
                else if (shi == 9)
                {
                    result.Append("XC");
                    shi = 0;
                }
                else
                {
                    result.Append('L');
                    shi -= 5;
                }
            }
            while (shi > 0)
            {
                result.Append('X');
                shi--;
            }


            if (ge >= 4)
            {
                if (ge == 4)
                {
                    result.Append("IV");
                    ge = 0;
                }
                else if (ge == 9)
                {
                    result.Append("IX");
                    ge = 0;
                }
                else
                {
                    result.Append('V');
                    ge -= 5;
                }
            }
            while (ge > 0)
            {
                result.Append('I');
                ge--;
            }

            return result.ToString();
        }
        public static int _13_Roman_to_Integer(string s)
        {
            int length = s.Length;
            int i = 0, qian = 0, bai = 0, shi = 0, ge = 0;

            while (i < length && s[i] == 'M')
            {
                i++;
                qian++;
            }

            if (i < length && s[i] == 'C' && i + 1 < length && s[i + 1] == 'M')
            {
                bai = 9;
                i++;
                i++;
            }
            else if (i < length && s[i] == 'C' && i + 1 < length && s[i + 1] == 'D')
            {
                bai = 4;
                i++;
                i++;
            }
            else
            {
                if (i < length && s[i] == 'D')
                {
                    bai += 5;
                    i++;
                }
                while (i < length && s[i] == 'C')
                {
                    i++;
                    bai++;
                }
            }



            if (i < length && s[i] == 'X' && i + 1 < length && s[i + 1] == 'C')
            {
                shi = 9;
                i++;
                i++;
            }
            else if (i < length && s[i] == 'X' && i + 1 < length && s[i + 1] == 'L')
            {
                shi = 4;
                i++;
                i++;
            }
            else
            {
                if (i < length && s[i] == 'L')
                {
                    shi += 5;
                    i++;
                }
                while (i < length && s[i] == 'X')
                {
                    i++;
                    shi++;
                }
            }

            if (i < length && s[i] == 'I' && i + 1 < length && s[i + 1] == 'X')
            {
                ge = 9;
                i++;
                i++;
            }
            else if (i < length && s[i] == 'I' && i + 1 < length && s[i + 1] == 'V')
            {
                ge = 4;
                i++;
                i++;
            }
            else
            {
                if (i < length && s[i] == 'V')
                {
                    ge += 5;
                    i++;
                }
                while (i < length && s[i] == 'I')
                {
                    i++;
                    ge++;
                }
            }
            return qian * 1000 + bai * 100 + shi * 10 + ge;
        }
        public static string _14_Longest_Common_Prefix(string[] strs)
        {
            string prefix = "";

            if (strs.Length == 0)
                return prefix;
            int minlength = int.MaxValue;
            for (int i = 0; i < strs.Length; i++)
            {
                if (strs[i].Length < minlength)
                    minlength = strs[i].Length;
            }
            for (int i = 0; i < minlength; i++)
            {
                bool ismatch = true;
                for (int j = 1; j < strs.Length; j++)
                {
                    if (strs[j][i] != strs[0][i])
                        ismatch = false;
                }

                if (ismatch)
                    prefix += strs[0][i];
                else
                    break;
            }

            return prefix;
        }
        public static IList<string> _17_Letter_Combinations_of_a_Phone_Number(string digits)
        {
            int resultcount = 1;
            if (digits.Length == 0)
                return new List<string>();
            for (int i = 0; i < digits.Length; i++)
            {
                if (digits[i] == '7' || digits[i] == '9')
                    resultcount *= 4;
                else
                    resultcount *= 3;
            }
            string[] results = new string[resultcount], resulttemp = new string[resultcount];

            for (int i = 0; i < digits.Length; i++)
            {
                string[] temp = new string[] { };
                switch (digits[i])
                {
                    case '2':
                        temp = new string[] { "a", "b", "c" };
                        break;
                    case '3':
                        temp = new string[] { "d", "e", "f" };
                        break;
                    case '4':
                        temp = new string[] { "g", "h", "i" };
                        break;
                    case '5':
                        temp = new string[] { "j", "k", "l" };
                        break;
                    case '6':
                        temp = new string[] { "m", "n", "o" };
                        break;
                    case '7':
                        temp = new string[] { "p", "q", "r", "s" };
                        break;
                    case '8':
                        temp = new string[] { "t", "u", "v" };
                        break;
                    case '9':
                        temp = new string[] { "w", "x", "y", "z" };
                        break;
                    default:
                        temp = new string[] { };
                        break;
                }
                if (results[0] == null)
                {
                    for (int j = 0; j < temp.Length; j++)
                    {
                        results[j] = temp[j];
                        resulttemp[j] = temp[j];
                    }
                }
                else
                {
                    int num = 0;
                    for (int j = 0; resulttemp[j] != null; j++)
                    {
                        for (int k = 0; k < temp.Length; k++)
                        {
                            results[num++] = resulttemp[j] + temp[k];
                        }
                    }
                    results.CopyTo(resulttemp, 0);
                }
            }
            return results;
        }
        public static ListNode _19_Remove_Nth_Node_From_End_of_List(ListNode head, int n)
        {
            ListNode p = head, q = head;
            while (n-- > 0)
                q = q.next;
            if (q == null)
                return head.next;
            while (q.next != null)
            {
                p = p.next;
                q = q.next;
            }
            q = p.next;
            p.next = q.next;
            return head;
        }
        public static bool _20_Valid_Parentheses(string s)
        {
            Stack<char> result = new Stack<char>();
            foreach (var item in s)
            {
                if (item == '(' || item == '[' || item == '{' || result.Count == 0)
                    result.Push(item);
                else
                {
                    if (item == ')' && result.Peek() == '(')
                        result.Pop();
                    else if (item == ']' && result.Peek() == '[')
                        result.Pop();
                    else if (item == '}' && result.Peek() == '{')
                        result.Pop();
                    else
                        result.Push(item);
                }
            }
            return result.Count == 0;
        }
        public static ListNode _21_Merge_Two_Sorted_Lists(ListNode l1, ListNode l2)
        {
            ListNode head = new ListNode(0), p = head;

            while (l1 != null && l2 != null)
            {
                if (l1.val < l2.val)
                {
                    p.next = l1;
                    p = p.next;
                    l1 = l1.next;
                }
                else
                {
                    p.next = l2;
                    p = p.next;
                    l2 = l2.next;
                }
            }
            if (l2 != null)
                l1 = l2;
            while (l1 != null)
            {
                p.next = l1;
                p = p.next;
                l1 = l1.next;
            }

            return head.next;
        }
        public static int _26_Remove_Duplicates_from_Sorted_Array(int[] nums)
        {
            int length = 0;
            if (nums.Length == 0)
                return 0;
            for (int i = 0; i < nums.Length || nums[length - 1] != nums[nums.Length - 1]; i++)
            {
                if (length > 0)
                {
                    if (nums[i] != nums[length - 1])
                        length++;
                    nums[length - 1] = nums[i];
                }
                else
                    nums[length++] = nums[i];
            }
            return length;
        }
        public static int _27_Remove_Element(int[] nums, int val)
        {
            int length = 0;
            for (int i = 0; i < nums.Length; i++)
            {
                int temp = nums[i];
                if (temp != val)
                {
                    nums[length++] = temp;
                }
            }
            return length;
        }
        public static int _28_Implement_strStr(string haystack, string needle)
        {
            int indexh = 0, indexn = 0, lengthh = haystack.Length, lengthn = needle.Length;
            if (lengthn == 0)
                return 0;
            if (lengthh == 0)
                return -1;
            while (indexn < lengthn && indexh < lengthh)
            {
                if (haystack[indexh] == needle[indexn])
                    indexn++;
                else
                {
                    indexh -= indexn;
                    indexn = 0;
                }
                indexh++;
            }
            return indexh == lengthh && indexn != lengthn ? -1 : indexh - lengthn;
        }
        public static int _461_Hamming_Distance(int x, int y)
        {
            int distance = 0;

            while (x != 0 && y != 0)
            {
                if (x % 2 != y % 2)
                    distance++;
                x /= 2;
                y /= 2;
            }
            if (y != 0)
                x = y;
            while (x != 0)
            {
                if (x % 2 != 0)
                    distance++;
                x /= 2;
            }
            return distance;
        }
        public static string _344_Reverse_String(string s)
        {
            char[] chararray = s.ToArray();
            for (int i = 0, j = s.Length - 1; i < j; i++, j--)
            {
                char temp = chararray[i];
                chararray[i] = chararray[j];
                chararray[j] = temp;
            }
            return new string(chararray);
        }
        public static int _463_Island_Perimeter(int[,] grid)
        {
            int length = 0, height = grid.GetLength(0), width = grid.GetLength(1);
            for (int i = 0; i < height; i++)
            {
                for (int j = 0; j < width; j++)
                {
                    if (grid[i, j] == 1)
                    {
                        if (j == 0 || grid[i, j - 1] == 0)
                            length++;
                        if (j == width - 1 || grid[i, j + 1] == 0)
                            length++;
                        if (i == 0 || grid[i - 1, j] == 0)
                            length++;
                        if (i == height - 1 || grid[i + 1, j] == 0)
                            length++;
                    }
                }
            }

            return length;
        }
        public static IList<int> _448_Find_All_Numbers_Disappeared_in_an_Array(int[] nums)
        {
            //简直就是天才
            List<int> result = new List<int>();
            for (int i = 0; i < nums.Length; i++)
            {
                int index = Math.Abs(nums[i]) - 1;
                if (nums[index] > 0)
                {
                    nums[index] = -nums[index];
                }
            }

            for (int j = 1; j <= nums.Length; j++)
            {
                if (nums[j - 1] > 0)
                {
                    result.Add(j);
                }
            }
            return result;
        }
        public static int _136_Single_Number(int[] nums)
        {
            int max = nums[0], min = nums[0];
            for (int i = 0; i < nums.Length; i++)
            {
                if (nums[i] > max)
                    max = nums[i];
                if (nums[i] < min)
                    min = nums[i];
            }

            int[] number = new int[max + 1 - min];
            for (int i = 0; i < nums.Length; i++)
            {
                number[nums[i] - min]++;
            }

            for (int i = 0; i <= max - min; i++)
            {
                if (number[i] == 1)
                    return i + min;
            }

            return 0;
        }
        public static int _104_Maximum_Depth_of_Binary_Tree(TreeNode root)
        {
            Stack<TreeNode> stack = new Stack<TreeNode>();
            int length = 0, i = 0;

            if (root == null)
                return length;

            stack.Push(root);
            length++;
            i++;

            TreeNode pre = stack.Peek(), temp = stack.Peek();
            while (stack.Count != 0)
            {
                temp = stack.Peek();
                if (temp.left != null && temp.left != pre)
                {
                    stack.Push(temp.left);
                    i++;
                }
                else if (temp.right != null)
                {
                    stack.Push(temp.right);
                    i++;
                }
                else
                {
                    while (stack.Count != 0 && temp.right == null || stack.Count != 0 && temp.right == pre)
                    {
                        pre = stack.Peek();
                        stack.Pop();
                        if (stack.Count != 0)
                            temp = stack.Peek();
                        i--;
                    }
                }
                if (i > length)
                    length = i;
            }

            return length;
        }
        public static int _258_Add_Digits(int num)
        {
            while (num >= 10)
            {
                List<int> yushu = new List<int>();
                while (num != 0)
                {
                    yushu.Add(num % 10);
                    num = num / 10;
                }
                foreach (var item in yushu)
                {
                    num += item;
                }
            }

            return num;
        }
        public static TreeNode _226_Invert_Binary_Tree(TreeNode root)
        {
            Queue<TreeNode> queue = new Queue<TreeNode>();

            if (root == null)
                return root;

            queue.Enqueue(root);
            while (queue.Count != 0)
            {
                Queue<TreeNode> qnext = new Queue<TreeNode>();
                while (queue.Count != 0)
                {
                    TreeNode node = queue.Dequeue();
                    TreeNode left = node.left, right = node.right;
                    node.left = right;
                    node.right = left;
                    if (left != null)
                        qnext.Enqueue(left);
                    if (right != null)
                        qnext.Enqueue(right);
                }
                queue = qnext;
            }

            return root;
        }
        public static void _283_Move_Zeroes(int[] nums)
        {
            int count = 0;
            for (int i = 0; i < nums.Length; i++)
            {
                if (nums[i] != 0)
                {
                    nums[count++] = nums[i];
                }
            }
            for (int i = count; i < nums.Length; i++)
            {
                nums[i] = 0;
            }

            foreach (var item in nums)
            {
                Console.WriteLine(item);
            }
        }
        public static void _237_Delete_Node_in_a_Linked_List(ListNode node)
        {
            while (node != null)
            {
                node.val = node.next.val;
                if (node.next.next == null)
                    node.next = null;
                node = node.next;
            }
        }
        public static int _404_Sum_of_Left_Leaves(TreeNode root)
        {
            int count = 0;
            Stack<TreeNode> queue = new Stack<TreeNode>();

            if (root == null)
                return 0;

            queue.Push(root);
            Console.WriteLine(root.val);
            TreeNode prenode = queue.Peek();
            while (queue.Count != 0)
            {
                TreeNode node = queue.Peek();

                if (node.left != null && node.left != prenode && node.right != prenode)
                {
                    Console.WriteLine(node.left.val);
                    queue.Push(node.left);
                }
                else if (node.right != null && node.right != prenode)
                {
                    Console.WriteLine(node.right.val);
                    queue.Push(node.right);
                }
                else
                {
                    prenode = node;
                    queue.Pop();

                    if (node.left == null && node.right == null && queue.Count != 0 && queue.Peek().left == prenode)
                        count += node.val;
                }
            }

            Console.WriteLine(count);

            return count;
        }
        public static int[] _349_Intersection_of_Two_Arrays(int[] nums1, int[] nums2)
        {
            List<int> result = new List<int>();

            foreach (var item1 in nums1)
            {
                foreach (var item2 in nums2)
                {
                    if (item1 == item2)
                    {
                        bool has = false;
                        foreach (var item3 in result)
                        {
                            if (item3 == item1)
                                has = true;
                        }
                        if (!has)
                            result.Add(item1);
                    }
                }
            }
            return result.ToArray();
        }
        public static string _168_Excel_Sheet_Column_Title(int n)
        {
            string result = "";
            while (n > 0)
            {
                int num = n % 26;
                switch (num)
                {
                    case 1: result = "A" + result; break;
                    case 2: result = "B" + result; break;
                    case 3: result = "C" + result; break;
                    case 4: result = "D" + result; break;
                    case 5: result = "E" + result; break;
                    case 6: result = "F" + result; break;
                    case 7: result = "G" + result; break;
                    case 8: result = "H" + result; break;
                    case 9: result = "I" + result; break;
                    case 10: result = "J" + result; break;
                    case 11: result = "K" + result; break;
                    case 12: result = "L" + result; break;
                    case 13: result = "M" + result; break;
                    case 14: result = "N" + result; break;
                    case 15: result = "O" + result; break;
                    case 16: result = "P" + result; break;
                    case 17: result = "Q" + result; break;
                    case 18: result = "R" + result; break;
                    case 19: result = "S" + result; break;
                    case 20: result = "T" + result; break;
                    case 21: result = "U" + result; break;
                    case 22: result = "V" + result; break;
                    case 23: result = "W" + result; break;
                    case 24: result = "X" + result; break;
                    case 25: result = "Y" + result; break;
                    case 0: result = "Z" + result; break;
                    default:
                        break;
                }
                n = n % 26 == 0 ? n / 26 - 1 : n / 26;
            }

            return result;
        }
        public static bool _100_Same_Tree(TreeNode p, TreeNode q)
        {
            if (p == null && q == null)
                return true;
            else if (p == null && q != null)
                return false;
            else if (p != null && q == null)
                return false;
            Queue<TreeNode> queueq = new Queue<TreeNode>(), queuep = new Queue<TreeNode>();
            queueq.Enqueue(q);
            queuep.Enqueue(p);
            while (queuep.Count != 0 && queueq.Count != 0)
            {
                TreeNode nodeq = queueq.Dequeue(), nodep = queuep.Dequeue();
                if (nodeq.val != nodep.val || nodep.left != null && nodeq.left == null || nodep.right != null && nodeq.right == null || nodep.left == null && nodeq.left != null || nodep.right == null && nodeq.right != null)
                    return false;

                if (nodeq.left != null)
                    queueq.Enqueue(nodeq.left);
                if (nodeq.right != null)
                    queueq.Enqueue(nodeq.right);
                if (nodep.left != null)
                    queuep.Enqueue(nodep.left);
                if (nodep.right != null)
                    queuep.Enqueue(nodep.right);
            }
            if (queuep.Count != 0 || queueq.Count != 0)
                return false;

            return true;
        }
        public static int _171_Excel_Sheet_Column_Number(string s)
        {
            int num = 0, shi = 1;
            for (int i = s.Length - 1; i >= 0; i--)
            {
                switch (s[i])
                {
                    case 'A': num += 1 * shi; break;
                    case 'B': num += 2 * shi; break;
                    case 'C': num += 3 * shi; break;
                    case 'D': num += 4 * shi; break;
                    case 'E': num += 5 * shi; break;
                    case 'F': num += 6 * shi; break;
                    case 'G': num += 7 * shi; break;
                    case 'H': num += 8 * shi; break;
                    case 'I': num += 9 * shi; break;
                    case 'J': num += 10 * shi; break;
                    case 'K': num += 11 * shi; break;
                    case 'L': num += 12 * shi; break;
                    case 'M': num += 13 * shi; break;
                    case 'N': num += 14 * shi; break;
                    case 'O': num += 15 * shi; break;
                    case 'P': num += 16 * shi; break;
                    case 'Q': num += 17 * shi; break;
                    case 'R': num += 18 * shi; break;
                    case 'S': num += 19 * shi; break;
                    case 'T': num += 20 * shi; break;
                    case 'U': num += 21 * shi; break;
                    case 'V': num += 22 * shi; break;
                    case 'W': num += 23 * shi; break;
                    case 'X': num += 24 * shi; break;
                    case 'Y': num += 25 * shi; break;
                    case 'Z': num += 26 * shi; break;
                    default:
                        break;
                }
                shi *= 26;
            }

            return num;
        }
        public static ListNode _206_Reverse_Linked_List(ListNode head)
        {
            Stack<ListNode> stack = new Stack<ListNode>();

            while (head != null)
            {
                stack.Push(head);
                head = head.next;
            }

            ListNode root = new ListNode(0), p = root;
            while (stack.Count != 0)
            {
                p.next = stack.Pop();
                p = p.next;
            }
            p.next = null;
            return root.next;
        }
        public static string _415_Add_Strings(string num1, string num2)
        {
            int carry = 0;
            string result = "";

            for (int i = num1.Length - 1, j = num2.Length - 1; i >= 0 || j >= 0; i--, j--)
            {
                int sum = (i >= 0 ? num1[i] : '0') + (j >= 0 ? num2[j] : '0') + carry - 96;
                result = sum % 10 + result;
                carry = sum / 10;
            }
            if (carry != 0)
                result = carry + result;

            return result;
        }
        public static bool _326_Power_of_Three(int n)
        {
            if (n <= 0)
                return false;
            while (n > 1)
            {
                if (n % 3 != 0)
                    return false;
                n /= 3;
            }
            return true;
        }
        public static ListNode _83_Remove_Duplicates_from_Sorted_List(ListNode head)
        {
            if (head == null)
                return null;
            ListNode p = head;
            int value = p.val;
            while (p.next != null)
            {
                if (p.next.val != p.val)
                    p = p.next;
                else
                    p.next = p.next.next;
            }

            return head;
        }
        public static bool _231_Power_of_Two(int n)
        {
            if (n < 1)
                return false;
            if (n == 1)
                return true;

            while (n > 1)
            {
                if (n % 2 != 0)
                    return false;
                n /= 2;
            }

            return true;
        }
        public static int _191_Number_of_1_Bits(uint n)
        {
            int count = 0;
            while (n > 0)
            {
                if (n % 2 == 1)
                    count++;
                n /= 2;
            }
            return count;
        }
        public static bool _263_Ugly_Number(int num)
        {
            if (num == 1)
                return true;
            if (num <= 0)
                return false;

            while (num != 1)
            {
                if (num % 30 == 0)
                    num /= 30;
                else if (num % 6 == 0)
                    num /= 6;
                else if (num % 10 == 0)
                    num /= 10;
                else if (num % 15 == 0)
                    num /= 5;
                else if (num % 2 == 0)
                    num /= 2;
                else if (num % 3 == 0)
                    num /= 3;
                else if (num % 5 == 0)
                    num /= 5;
                else
                    return false;
            }

            return true;
        }
        public static TreeNode _235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree(TreeNode root, TreeNode p, TreeNode q)
        {
            Stack<TreeNode> stackp = new Stack<TreeNode>(), stackq = new Stack<TreeNode>();
            if (root == null || p == null || q == null)
                return null;

            bool findp = false, findq = false;
            stackp.Push(root);
            stackq.Push(root);
            TreeNode prep = stackp.Peek(), preq = stackq.Peek();
            if (root.val == p.val)
                findp = true;
            if (root.val == q.val)
                findq = true;
            while (stackp.Count != 0 && stackq.Count != 0 && (!findp || !findq))
            {
                TreeNode nodep = stackp.Peek(), nodeq = stackq.Peek(), pushp = null, pushq = null;

                if (!findp)
                    if (nodep.left != null && nodep.left != prep && nodep.right != prep)
                    {
                        stackp.Push(nodep.left);
                        pushp = nodep.left;
                    }
                    else if (nodep.right != null && nodep.right != prep)
                    {
                        stackp.Push(nodep.right);
                        pushp = nodep.right;
                    }
                    else
                    {
                        prep = nodep;
                        stackp.Pop();
                    }
                if (pushp != null && pushp.val == p.val)
                    findp = true;

                if (!findq)
                    if (nodeq.left != null && nodeq.left != preq && nodeq.right != preq)
                    {
                        stackq.Push(nodeq.left);
                        pushq = nodeq.left;
                    }
                    else if (nodeq.right != null && nodeq.right != preq)
                    {
                        stackq.Push(nodeq.right);
                        pushq = nodeq.right;
                    }
                    else
                    {
                        preq = nodeq;
                        stackq.Pop();
                    }
                if (pushq != null && pushq.val == q.val)
                    findq = true;
            }
            if (!findp || !findq)
                return null;
            TreeNode[] tempp = stackp.ToArray(), tempq = stackq.ToArray();
            TreeNode result = tempp[0];
            for (int i = tempp.Length - 1, j = tempq.Length - 1; i >= 0 & j >= 0 && tempp[i].val == tempq[j].val; i--, j--)
            {
                result = tempp[i];
            }

            return result;
        }
        public static int _434_Number_of_Segments_in_a_String(string s)
        {
            int count = 0;
            char pre = 'z';

            for (int i = 0; i < s.Length; i++)
            {
                if (s[i] != ' ' && (pre == ' ' || i == 0))
                    count++;
                pre = s[i];
            }

            return count;
        }
        public static IList<IList<int>> _107_Binary_Tree_Level_Order_Traversal_II(TreeNode root)
        {
            if (root == null)
                return new List<IList<int>>();
            Queue<TreeNode> queue_1 = new Queue<TreeNode>(), queue_2 = new Queue<TreeNode>();
            queue_1.Enqueue(root);
            Stack<IList<int>> result = new Stack<IList<int>>();
            while (queue_1.Count != 0)
            {
                queue_2 = new Queue<TreeNode>();
                List<int> num = new List<int>();
                while (queue_1.Count != 0)
                {
                    TreeNode node = queue_1.Dequeue();
                    num.Add(node.val);
                    if (node.left != null)
                        queue_2.Enqueue(node.left);
                    if (node.right != null)
                        queue_2.Enqueue(node.right);
                }
                queue_1 = queue_2;
                result.Push(num);
            }

            return result.ToArray();
        }
        public static bool _342_Power_of_Four(int num)
        {
            if (num < 1)
                return false;
            if (num == 1)
                return true;

            while (num > 1)
            {
                if (num % 4 != 0)
                    return false;
                num /= 4;
            }

            return true;
        }
        public static string _345_Reverse_Vowels_of_a_String(string s)
        {
            char[] chararray = s.ToCharArray();
            int low = 0, high = chararray.Length - 1;

            while (low < high)
            {
                while (low < chararray.Length && chararray[low] != 'a' && chararray[low] != 'e' && chararray[low] != 'i' && chararray[low] != 'o' && chararray[low] != 'u' && chararray[low] != 'A' && chararray[low] != 'E' && chararray[low] != 'I' && chararray[low] != 'O' && chararray[low] != 'U')
                    low++;
                while (high >= 0 && chararray[high] != 'a' && chararray[high] != 'e' && chararray[high] != 'i' && chararray[high] != 'o' && chararray[high] != 'u' && chararray[high] != 'A' && chararray[high] != 'E' && chararray[high] != 'I' && chararray[high] != 'O' && chararray[high] != 'U')
                    high--;
                if (low < high)
                {
                    char temp = chararray[low];
                    chararray[low] = chararray[high];
                    chararray[high] = temp;
                    low++;
                    high--;
                }
            }

            return new string(chararray);
        }
        public static ListNode _24_Swap_Nodes_in_Pairs(ListNode head)
        {
            ListNode root = new ListNode(0);
            root.next = head;
            head = root;

            while (head.next != null && head.next.next != null)
            {
                ListNode p = head.next, q = p.next;
                p.next = q.next;
                q.next = p;
                head.next = q;
                head = p;
            }
            return root.next;
        }
        public static IList<IList<int>> _102_Binary_Tree_Level_Order_Traversal(TreeNode root)
        {
            if (root == null)
                return new List<IList<int>>();
            Queue<TreeNode> queue_1 = new Queue<TreeNode>(), queue_2 = new Queue<TreeNode>();
            queue_1.Enqueue(root);
            List<IList<int>> result = new List<IList<int>>();
            while (queue_1.Count != 0)
            {
                queue_2 = new Queue<TreeNode>();
                List<int> num = new List<int>();
                while (queue_1.Count != 0)
                {
                    TreeNode node = queue_1.Dequeue();
                    num.Add(node.val);
                    if (node.left != null)
                        queue_2.Enqueue(node.left);
                    if (node.right != null)
                        queue_2.Enqueue(node.right);
                }
                queue_1 = queue_2;
                result.Add(num);
            }

            return result.ToArray();
        }
        public static int[] _66_Plus_One(int[] digits)
        {
            int carry = 1;
            for (int i = digits.Length - 1; i >= 0; i--)
            {
                int num = digits[i] + carry;
                if (num >= 10)
                {
                    digits[i] = num % 10;
                    carry = num / 10;
                    if (i == 0)
                    {
                        int[] result = new int[digits.Length + 1];
                        result[0] = carry;
                        digits.CopyTo(result, 1);
                        return result;
                    }
                }
                else
                {
                    digits[i] = num;
                    carry = 0;
                }
            }

            return digits;
        }
        public static IList<IList<int>> _118_Pascal_s_Triangle(int numRows)
        {
            if (numRows == 0)
                return new List<IList<int>>();

            List<IList<int>> result = new List<IList<int>>();

            for (int i = 1; i <= numRows; i++)
            {
                int[] nums = new int[i];
                for (int j = 0; j < i; j++)
                {
                    if (j == 0 || j == i - 1)
                        nums[j] = 1;
                    else
                        nums[j] = result[i - 2][j - 1] + result[i - 2][j];
                }
                result.Add(nums);
            }

            return result;
        }
        public static int _441_Arranging_Coins(int n)
        {
            if (n <= 0)
                return 0;
            int height = 1;
            while (n >= height)
            {
                n -= height;
                height++;
            }
            return height - 1;
        }
        public static IList<int> _119_Pascal_s_Triangle_II(int rowIndex)
        {
            rowIndex++;
            if (rowIndex <= 0)
                return new int[0];
            int[] nums = new int[0];
            for (int i = 1; i <= rowIndex; i++)
            {
                int[] result = new int[i];
                for (int j = 0; j < i; j++)
                {
                    if (j == 0 || j == i - 1)
                        result[j] = 1;
                    else
                        result[j] = nums[j - 1] + nums[j];
                }
                if (i == rowIndex)
                    return result;
                else
                    nums = result;
            }
            return nums;
        }
        public static int _172_Factorial_Trailing_Zeroes(int n)
        {
            int count = 0;
            while (n > 0)
            {     //count the number of factor 5;
                count += n / 5;
                n /= 5;
            }
            return count;
        }
        public static IList<string> _257_Binary_Tree_Paths(TreeNode root)
        {
            Stack<TreeNode> queue = new Stack<TreeNode>();

            if (root == null)
                return new List<string>();

            List<string> result = new List<string>();
            queue.Push(root);
            TreeNode prenode = queue.Peek();
            while (queue.Count != 0)
            {
                TreeNode node = queue.Peek();

                if (node.left != null && node.left != prenode && node.right != prenode)
                {
                    queue.Push(node.left);
                }
                else if (node.right != null && node.right != prenode)
                {
                    queue.Push(node.right);
                }
                else
                {
                    if (node.left == null && node.right == null)
                    {
                        StringBuilder path = new StringBuilder();
                        Stack<TreeNode> temp = new Stack<TreeNode>(queue);

                        while (temp.Count != 0)
                        {
                            if (temp.Count != 1)
                                path.Append(temp.Peek().val + "->");
                            else
                                path.Append(temp.Peek().val);
                            temp.Pop();
                        }
                        if (path.Length != 0)
                            result.Add(path.ToString());
                    }
                    prenode = node;
                    queue.Pop();
                }
            }

            return result;
        }
        public static string _299_Bulls_and_Cows(string secret, string guess)
        {
            int bull = 0, cows = 0;
            char[] s = new char[secret.Length], g = new char[guess.Length];
            int sl = 0, gl = 0;
            for (int i = 0; i < secret.Length; i++)
            {
                if (secret[i] == guess[i])
                    bull++;
                else
                {
                    s[sl++] = secret[i];
                    g[gl++] = guess[i];
                }
            }

            for (int i = 0; i < sl; i++)
            {
                bool has = false;
                for (int j = 0; j < gl; j++)
                {
                    if (s[i] == g[j])
                    {
                        has = true;
                        g[j] = 'x';
                        break;
                    }
                }
                if (has)
                    cows++;
            }

            return bull + "A" + cows + "B";
        }
        public static bool _112_Path_Sum(TreeNode root, int sum)
        {
            Stack<TreeNode> queue = new Stack<TreeNode>();

            if (root == null)
                return false;

            List<string> result = new List<string>();
            queue.Push(root);
            TreeNode prenode = queue.Peek();
            while (queue.Count != 0)
            {
                TreeNode node = queue.Peek();

                if (node.left != null && node.left != prenode && node.right != prenode)
                {
                    queue.Push(node.left);
                }
                else if (node.right != null && node.right != prenode)
                {
                    queue.Push(node.right);
                }
                else
                {
                    if (node.left == null && node.right == null)
                    {
                        StringBuilder path = new StringBuilder();
                        Stack<TreeNode> temp = new Stack<TreeNode>(queue);

                        int tsum = 0;
                        while (temp.Count != 0)
                        {
                            tsum += temp.Peek().val;
                            temp.Pop();
                        }
                        if (tsum == sum)
                            return true;
                    }
                    prenode = node;
                    queue.Pop();
                }
            }

            return false;
        }
        public static bool _205_Isomorphic_Strings(string s, string t)
        {
            if (s.Length != t.Length)
                return false;
            Dictionary<char, char> isomorphic = new Dictionary<char, char>();

            for (int i = 0; i < s.Length; i++)
            {
                if (isomorphic.Keys.Contains(s[i]))
                {
                    if (t[i] != isomorphic[s[i]])
                        return false;
                }
                else
                {
                    if (!isomorphic.Values.Contains(t[i]))
                        isomorphic.Add(s[i], t[i]);
                    else if (isomorphic.SingleOrDefault(p => p.Value == t[i]).Key != s[i])
                        return false;
                }
            }

            return true;
        }
        public static int _111_Minimum_Depth_of_Binary_Tree(TreeNode root)
        {
            Stack<TreeNode> stack = new Stack<TreeNode>();
            int length = int.MaxValue, i = 0;

            if (root == null)
                return 0;

            stack.Push(root);
            i++;

            TreeNode pre = stack.Peek(), temp = stack.Peek();
            while (stack.Count != 0)
            {
                temp = stack.Peek();
                if (temp.left != null && temp.left != pre && temp.right != pre)
                {
                    stack.Push(temp.left);
                    i++;
                }
                else if (temp.right != null && temp.right != pre)
                {
                    stack.Push(temp.right);
                    i++;
                }
                else
                {
                    pre = stack.Pop();
                    Console.WriteLine(pre.val);
                    if (i < length && pre.left == null && pre.right == null)
                        length = i;
                    i--;
                }
            }

            return length;
        }
        public static int _223_Rectangle_Area(int A, int B, int C, int D, int E, int F, int G, int H)
        {
            int area = 0;
            int area1 = (C - A) * (D - B), area2 = (G - E) * (H - F);
            if (B - H >= 0 || F - D >= 0 || E - C >= 0 || A - G >= 0)
                return area1 + area2;
            if (E <= A && F <= B && G >= C && H >= D || A <= E && B <= F && C >= G && D >= H)
                return area1 > area2 ? area1 : area2;
            int height1 = H - B, height2 = H - F, height3 = D - F, height4 = D - B;
            int height = height1 >= 0 ? height1 : height2 >= 0 ? height2 : height3 >= 0 ? height3 : height4 >= 0 ? height4 : 0;
            if (height > height1 && height1 >= 0)
                height = height1;
            if (height > height2 && height2 >= 0)
                height = height2;
            if (height > height3 && height3 >= 0)
                height = height3;
            if (height > height4 && height4 >= 0)
                height = height4;

            int width1 = C - E, width2 = C - A, width3 = G - A, width4 = G - E;
            int width = width1 >= 0 ? width1 : width2 >= 0 ? width2 : width3 >= 0 ? width3 : width4 >= 0 ? width4 : 0;
            if (width > width1 && width1 >= 0)
                width = width1;
            if (width > width2 && width2 >= 0)
                width = width2;
            if (width > width3 && width3 >= 0)
                width = width3;
            if (width > width4 && width4 >= 0)
                width = width4;

            if (height > 0 && width > 0)
                area = height * width;

            return area1 + area2 - area;
        }
        public static bool _234_Palindrome_Linked_List(ListNode head)
        {
            if (head == null)
                return true;
            Queue<int> queue = new Queue<int>();
            Stack<int> stack = new Stack<int>();

            while (head != null)
            {
                queue.Enqueue(head.val);
                stack.Push(head.val);
                head = head.next;
            }
            while (queue.Count > 0 && stack.Count > 0)
            {
                if (queue.Peek() != stack.Peek())
                    return false;
                queue.Dequeue();
                stack.Pop();
            }
            return true;
        }
        public static bool _219_Contains_Duplicate_II(int[] nums, int k)
        {
            for (int i = 0; i < nums.Length - 1; i++)
            {
                for (int j = i + 1; j <= i + k && j < nums.Length; j++)
                {
                    if (nums[i] == nums[j])
                        return true;
                }
            }
            return false;
        }
        public static IList<IList<int>> _15_3Sum(int[] nums)
        {
            IList<IList<int>> results = new List<IList<int>>();
            for (int i = 0; i < nums.Length - 2; i++)
            {
                for (int j = i + 1; j < nums.Length - 1; j++)
                {
                    for (int k = j + 1; k < nums.Length; k++)
                    {
                        if (nums[i] + nums[j] + nums[k] == 0)
                        {
                            int max = Math.Max(Math.Max(nums[i], nums[j]), nums[k]);
                            int min = Math.Min(Math.Min(nums[i], nums[j]), nums[k]);
                            int medium = 0 - max - min;
                            int[] item = new int[] { min, medium, max };
                            if (!results.Contains(item))
                                results.Add(item);
                        }
                    }
                }
            }
            return results;
        }
        public static int _29_Divide_Two_Integers(int dividend, int divisor)
        {
            if (divisor == 0)
                return int.MaxValue;
            if (Math.Abs((long)dividend) < Math.Abs((long)divisor) || dividend == 0)
                return 0;

            if ((long)dividend * divisor >= 0)
            {
                int quotient = 1, sum = divisor;
                while (sum <= dividend && dividend > 0 || sum > dividend && dividend < 0)
                {
                    sum = divisor;
                    for (int i = 0; i < quotient; i++)
                    {
                        sum += divisor;
                    }
                    quotient++;
                }
                return quotient - 1;
            }
            else
            {
                int quotient = 1, sum = -divisor;
                while (sum <= dividend && dividend > 0 || sum > dividend && dividend < 0)
                {
                    sum = -divisor;
                    for (int i = 0; i < quotient; i++)
                    {
                        sum += -divisor;
                    }
                    quotient++;
                }
                return -quotient + 1;
            }
            //int _dividend = dividend < 0 ? -dividend : dividend, _divisor = divisor < 0 ? -divisor : divisor;
            //if (divisor == 0)
            //    return int.MaxValue;
            //if (dividend < divisor && divisor * dividend > 0)
            //    return 0;
            //int quotient = 1, sum = _divisor;
            //while (sum <= _dividend)
            //{
            //    sum = _divisor;
            //    for (int i = 0; i < quotient; i++)
            //    {
            //        sum += _divisor;
            //    }
            //    quotient++;
            //}
            //return divisor * dividend > 0 ? quotient - 1 : -(quotient - 1);
        }
        public static int _387_First_Unique_Character_in_a_String(string s)
        {
            return 0;
        }
        public static int _121_Best_Time_to_Buy_and_Sell_Stock(int[] prices)
        {
            if (prices.Length == 0)
                return 0;
            int high = prices.Length - 1, low = 0;
            int max = prices[prices.Length - 1], min = prices[0];

            while (low < high)
            {
                while (low < prices.Length && prices[low] >= min && low < high)
                    low++;
                while (high >= 0 && prices[high] <= max && low < high)
                    high--;
                if (low < high)
                {
                    max = prices[high];
                    min = prices[low];
                }
            }

            return max > min ? max - min : 0;
        }
        public static long _70_Climbing_Stairs(int n)
        {
            if (n <= 0)
                return 0;
            long count = 1;
            for (int i = 1; i <= n / 2; i++)
            {
                double num1 = 1, num2 = 1;
                int bottom = n - i, top = i;
                for (int j = bottom, k = 0; k < top; j--, k++)
                {
                    num1 *= j;
                }
                for (int j = top; j > 0; j--)
                {
                    num2 *= j;
                }
                count += (long)(num1 / num2);
            }
            if (count > int.MaxValue)
                return count;
            else
                return (int)count;

        }
        public static bool _141_Linked_List_Cycle(ListNode head)
        {
            if (head == null)
                return false;
            List<ListNode> nodes = new List<ListNode>();
            bool duplicated = false;
            while (head != null && !duplicated)
            {
                duplicated = false;
                foreach (var item in nodes)
                {
                    if (item == head)
                    {
                        duplicated = true;
                        break;
                    }
                }
                if (duplicated)
                    break;
                nodes.Add(head);
                head = head.next;
            }
            return duplicated;
        }
        public static void _88_Merge_Sorted_Array(int[] nums1, int m, int[] nums2, int n)
        {
            int length = 0, i = 0, j = 0;
            int[] nums3 = (int[])(nums1.Clone());
            while (i < m && j < n)
            {
                if (nums3[i] < nums2[j])
                {
                    nums1[length] = nums3[i];
                    length++; i++;
                }
                else
                {
                    nums1[length] = nums2[j];
                    length++; j++;
                }
            }
            while (i < m)
            {
                nums1[length] = nums3[i];
                length++; i++;
            }
            while (j < n)
            {
                nums1[length] = nums2[j];
                length++; j++;
            }

            foreach (var item in nums1)
            {
                Console.WriteLine(item);
            }
        }
        public static int _58_Length_of_Last_Word(string s)
        {
            int length = 0;
            char[] chararray = s.TrimEnd().ToCharArray();

            for (int i = 0; i < chararray.Length; i++)
            {
                if (chararray[i] != ' ')
                    length++;
                else
                    length = 0;
            }

            return length;
        }
        public static ListNode _203_Remove_Linked_List_Elements(ListNode head, int val)
        {
            if (head == null)
                return null;
            ListNode root = new ListNode(0);
            root.next = head;
            ListNode p = root, q = root.next;
            while (q != null)
            {
                if (q.val == val)
                {
                    p.next = q.next;
                    q = q.next;
                }
                else
                {
                    p = q;
                    q = q.next;
                }
            }

            return root.next;
        }
        public static string _67_Add_Binary(string a, string b)
        {
            char[] chararray = new char[a.Length > b.Length ? a.Length + 1 : b.Length + 1];
            int carry = 0, i = a.Length - 1, j = b.Length - 1, k = chararray.Length - 1;
            while (i >= 0 && j >= 0)
            {
                int num = a[i] + b[j] + carry - 96;
                if (num == 3)
                {
                    chararray[k] = '1';
                    carry = 1;
                }
                else if (num == 2)
                {
                    chararray[k] = '0';
                    carry = 1;
                }
                else
                {
                    chararray[k] = num.ToString()[0];
                    carry = 0;
                }
                i--;
                j--;
                k--;
            }
            while (i >= 0)
            {
                int num = a[i] + carry - 48;
                if (num == 3)
                {
                    chararray[k] = '1';
                    carry = 1;
                }
                else if (num == 2)
                {
                    chararray[k] = '0';
                    carry = 1;
                }
                else
                {
                    chararray[k] = num.ToString()[0];
                    carry = 0;
                }
                i--;
                k--;
            }
            while (j >= 0)
            {
                int num = b[j] + carry - 48;
                if (num == 3)
                {
                    chararray[k] = '1';
                    carry = 1;
                }
                else if (num == 2)
                {
                    chararray[k] = '0';
                    carry = 1;
                }
                else
                {
                    chararray[k] = num.ToString()[0];
                    carry = 0;
                }
                j--;
                k--;
            }
            if (carry != 0)
                chararray[0] = carry.ToString()[0];
            else if (k == 0)
                chararray[0] = ' ';

            return (new string(chararray)).Trim();
        }
        public static int _396_Rotate_Function(int[] A)
        {
            int result = 0;
            for (int j = 0; j < A.Length; j++)
            {
                int num = 0;
                for (int i = 0; i < A.Length; i++)
                {
                    num += (i + j > A.Length - 1 ? i + j - A.Length : i + j) * A[i];
                }
                if (num > result || j == 0)
                    result = num;
            }
            return result;
        }
        public static int _400_Nth_Digit(int n)
        {
            if (n < 10)
                return n;
            else if (n >= 10 && n < 190)
            {
                if ((n + 10) % 20 % 2 == 0)
                    return (n + 10) / 20;
                else
                    return (n + 10) % 20 / 2;
            }
            else if (n >= 190 && n < 2890)
            {
                //if ((n + 110) % 3 == 0)
                //    return (n + 100) / 300 + 1;
                //else if ((n + 110) % 3 == 1)
                //    return (n + 10) % 20 / 2;
                //else
                return 0;
            }
            else
                return 0;
        }
        public static int _475_Heaters(int[] houses, int[] heaters)
        {
            for (int i = 0; i < houses.Length - 1; i++)
            {
                for (int j = 0; j < houses.Length - 1 - i; j++)
                {
                    if (houses[j] > houses[j + 1])
                    {
                        int temp = houses[j];
                        houses[j] = houses[j + 1];
                        houses[j + 1] = temp;
                    }
                }
            }
            for (int i = 0; i < heaters.Length - 1; i++)
            {
                for (int j = 0; j < heaters.Length - 1 - i; j++)
                {
                    if (heaters[j] > heaters[j + 1])
                    {
                        int temp = heaters[j];
                        heaters[j] = heaters[j + 1];
                        heaters[j + 1] = temp;
                    }
                }
            }
            if (heaters[0] > houses[houses.Length - 1])
                return heaters[0] - houses[0];
            if (heaters[heaters.Length - 1] < houses[0])
                return houses[houses.Length - 1] - heaters[heaters.Length - 1];
            int index = 0;
            while (heaters[index] < houses[0] && index < heaters.Length)
                index++;
            if (index == heaters.Length)
                index--;

            int result = 0;
            for (int i = 0; i < heaters.Length - 1; i++)
            {
                if ((heaters[i + 1] - heaters[i]) / 2 > result)
                    result = (heaters[i + 1] - heaters[i]) / 2;
            }
            if (heaters[0] > houses[0] && heaters[0] - houses[0] > result)
                result = heaters[0] - houses[0];
            if (heaters[heaters.Length - 1] < houses[houses.Length - 1] && houses[houses.Length - 1] - heaters[heaters.Length - 1] > result)
                result = houses[houses.Length - 1] - heaters[heaters.Length - 1];

            return result;
        }
        public static ListNode _160_Intersection_of_Two_Linked_Lists(ListNode headA, ListNode headB)
        {
            ListNode q = headA, p = headB;
            int lengthA = 0, lengthB = 0;
            while (q != null)
            {
                q = q.next;
                lengthA++;
            }
            while (p != null)
            {
                p = p.next;
                lengthB++;
            }
            q = headA;
            p = headB;
            while (lengthA > lengthB)
            {
                q = q.next;
                lengthA--;
            }
            while (lengthB > lengthA)
            {
                p = p.next;
                lengthB--;
            }
            while (q != null && p != null && q.val != p.val)
            {
                p = p.next; ;
                q = q.next;
            }

            return q;
        }
        public static uint _190_Reverse_Bits(uint n)
        {
            uint[] numbers = new uint[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
            int index = 31;
            while (n != 0)
            {
                numbers[index] = n % 2;
                n /= 2;
                index--;
            }
            uint num = 1, result = 0;
            for (int i = 0; i < numbers.Length; i++)
            {
                result += num * numbers[i];
                num *= 2;
            }

            return result;
        }
        public static int _414_Third_Maximum_Number(int[] nums)
        {
            int[] max = new int[3];
            max[0] = nums[0];
            bool hasValue1 = false, hasValue2 = false;
            for (int i = 0; i < nums.Length; i++)
            {
                if (nums[i] >= max[0])
                {
                    if (nums[i] != max[0])
                    {
                        if (hasValue1)
                            hasValue2 = true;
                        hasValue1 = true;
                        max[2] = max[1];
                        max[1] = max[0];
                        max[0] = nums[i];
                    }
                }
                else if (nums[i] >= max[1] || !hasValue1)
                {
                    if (nums[i] != max[1])
                    {
                        hasValue1 = true;
                        max[2] = max[1];
                        max[1] = nums[i];
                    }
                }
                else if (nums[i] > max[2] || !hasValue2)
                {
                    hasValue2 = true;
                    max[2] = nums[i];
                }
            }

            return hasValue2 ? max[2] : max[0];
        }
        public static int _204_Count_Primes(int n)
        {
            if (n <= 2)
                return 0;
            int count = 0;
            for (int i = 2; i < n; i++)
            {
                if (i != 2 && i % 2 == 0 || i != 3 && i % 3 == 0 || i != 5 && i % 5 == 0 || i != 7 && i % 7 == 0 || i != 11 && i % 11 == 0)
                    continue;
                bool prime = true;
                for (int j = 2; j <= Math.Sqrt(i); j++)
                {
                    if (i % j == 0)
                    {
                        prime = false;
                        break;
                    }
                }
                if (prime)
                {
                    //Console.WriteLine(i);
                    count++;
                }
            }
            return count;
        }
        public static bool _125_Valid_Palindrome(string s)
        {
            int high = s.Length - 1, low = 0;

            while (high > low)
            {
                while (high > low && !(s[high] <= 122 && s[high] >= 97 || s[high] <= 90 && s[high] >= 65 || s[high] <= 57 && s[high] >= 48))
                    high--;
                while (high > low && !(s[low] <= 122 && s[low] >= 97 || s[low] <= 90 && s[low] >= 65 || s[low] <= 57 && s[low] >= 48))
                    low++;
                int ihigh = s[high] >= 97 ? s[high] : s[high] + 32, ilow = s[low] >= 97 ? s[low] : s[low] + 32;
                if (ihigh != ilow)
                    return false;
                high--;
                low++;
            }
            return true;
        }
        public static void _189_Rotate_Array(int[] nums, int k)
        {
            while (k > nums.Length)
                k -= nums.Length;
            int length = nums.Length - k;
            for (int i = 0; i < length / 2; i++)
            {
                int temp = nums[i];
                nums[i] = nums[length - 1 - i];
                nums[length - 1 - i] = temp;
            }
            foreach (var item in nums)
            {
                Console.Write(item + "\t");
            }
            Console.WriteLine();
            for (int i = length; i < (length + length + k) / 2; i++)
            {
                int temp = nums[i];
                nums[i] = nums[2 * length + k - 1 - i];
                nums[2 * length + k - 1 - i] = temp;
            }
            foreach (var item in nums)
            {
                Console.Write(item + "\t");
            }
            Console.WriteLine();
            for (int i = 0; i < nums.Length / 2; i++)
            {
                int temp = nums[i];
                nums[i] = nums[nums.Length - 1 - i];
                nums[nums.Length - 1 - i] = temp;
            }
            foreach (var item in nums)
            {
                Console.Write(item + "\t");
            }
            Console.WriteLine();
        }
        public static int _165_Compare_Version_Numbers(string version1, string version2)
        {
            while (version2.Length < version1.Length)
                version2 += ".0";
            while (version1.Length < version2.Length)
                version1 += ".0";
            string[] numbers1 = version1.Split('.'), numbers2 = version2.Split('.');
            int i = 0;
            for (i = 0; i < numbers1.Length && i < numbers2.Length; i++)
            {
                int number1 = int.Parse(numbers1[i]), number2 = int.Parse(numbers2[i]);
                if (number1 > number2)
                    return 1;
                else if (number1 < number2)
                    return -1;
            }
            return 0;
        }
        public static int[] _338_Counting_Bits(int num)
        {
            int[] result = new int[num + 1];
            for (int i = 0; i <= num; i++)
            {
                int number = i, count = 0;
                while (number != 0)
                {
                    if (number % 2 == 1)
                        count++;
                    number /= 2;
                }
                result[i] = count;
            }
            return result;
        }
        public static int[] _260_Single_Number_III(int[] nums)
        {
            Dictionary<int, int> frequency = new Dictionary<int, int>();
            for (int i = 0; i < nums.Length; i++)
            {
                if (frequency.Keys.Contains(nums[i]))
                    frequency[nums[i]]++;
                else
                    frequency.Add(nums[i], 1);
            }
            List<int> result = new List<int>();
            foreach (var item in frequency)
            {
                if (item.Value == 1)
                    result.Add(item.Key);
            }
            return result.ToArray();
        }
        public static IList<int> _442_Find_All_Duplicates_in_an_Array(int[] nums)
        {
            int[] frequency = new int[nums.Length + 1];
            for (int i = 0; i < nums.Length; i++)
            {
                frequency[nums[i]]++;
            }
            List<int> result = new List<int>();
            for (int i = 0; i < frequency.Length; i++)
            {
                if (frequency[i] == 2)
                    result.Add(i);
            }
            return result;
        }
        #endregion
        public static int _150_Evaluate_Reverse_Polish_Notation(string[] tokens)
        {
            Stack<int> numbers = new Stack<int>();
            for (int i = 0; i < tokens.Length; i++)
            {
                if (tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/")
                {
                    int num1 = numbers.Pop(), num2 = numbers.Pop();
                    switch (tokens[i])
                    {
                        case "+":
                            numbers.Push(num2 + num1);
                            break;
                        case "-":
                            numbers.Push(num2 - num1);
                            break;
                        case "*":
                            numbers.Push(num2 * num1);
                            break;
                        case "/":
                            numbers.Push(num2 / num1);
                            break;
                        default:
                            break;
                    }
                }
                else
                {
                    numbers.Push(int.Parse(tokens[i]));
                }
            }
            return numbers.Pop();
        }
        public static string _43_Multiply_Strings(string num1, string num2)
        {
            if (num1 == "0" || num2 == "0")
                return "0";
            string[] products = new string[num2.Length];
            string zero = "";
            int maxlength = 0, carry = 0;
            for (int i = num2.Length - 1; i >= 0; i--)
            {
                carry = 0;
                int multiplier1 = num2[i] - 48;
                string product = string.Empty + zero;
                for (int j = num1.Length - 1; j >= 0; j--)
                {
                    int temp = multiplier1 * (num1[j] - 48) + carry;
                    product = (temp % 10) + product;
                    carry = temp / 10;
                }
                if (carry != 0)
                    product = carry + product;
                zero += "0";
                Console.WriteLine(product);
                if (product.Length > maxlength)
                    maxlength = product.Length;
                products[num2.Length - 1 - i] = product;
            }
            carry = 0;
            string result = "";
            for (int j = 0; j < maxlength; j++)
            {
                int sum = carry;
                for (int i = 0; i < num2.Length; i++)
                {
                    if (products[i].Length > j)
                    {
                        sum += products[i][products[i].Length - 1 - j] - 48;
                    }
                }
                result = (sum % 10) + result;
                carry = sum / 10;
            }
            if (carry != 0)
                result = carry + result;
            Console.WriteLine(result);

            return result;
        }
        public static double _50_Pow_x_n(double x, int n)
        {
            if (x == 0)
                return 0;
            if (x == 1)
                return 1;
            if (x == -1)
                return n % 2 == 0 ? 1 : -1;
            if (n == 0)
                return 1;
            if (n == 1)
                return x;
            if (n == -1)
                return 1 / x;
            double result = 1;
            bool negative = n > 0;
            long count = negative ? (long)n : -(long)n;
            x = negative ? x : 1 / x;
            while (count > 0)
            {
                if (result == 0)
                    break;
                result *= x;
                count--;
            }
            return result;
        }
        public static string _60_Permutation_Sequence(int n, int k)
        {
            int[] counts = new int[n];
            int num = 1, maxcount = 1;
            List<int> nums = new List<int>();
            for (int i = 0; i < n; i++)
            {
                num *= (i + 1);
                maxcount *= (i + 1);
                nums.Add(i + 1);
            }
            if (k > num)
                return "";
            for (int i = 0; i < n; i++)
            {
                num /= (n - i);
                counts[i] = num;
            }

            int[] index = new int[n];
            for (int i = 0; i < n - 1; i++)
            {
                index[i] = k / counts[i];
                k %= counts[i];
                maxcount /= (n - i);
                if (k == 0 && index[i] != 0)
                {
                    k = maxcount;
                    index[i]--;
                }
            }

            string result = "";
            for (int i = 0; i < n; i++)
            {
                result += nums[index[i]];
                nums.Remove(nums[index[i]]);
            }

            return result;
        }
        public static ListNode _148_Sort_List(ListNode head)
        {
            if (head == null)
                return null;
            ListNode root1 = new ListNode(head.val), root2 = new ListNode(0);
            root1.next = head;
            root2.next = null;
            ListNode p = root1, q = root1.next, maxp = root1, maxq = root1.next;

            while (q != null)
            {
                while (q != null)
                {
                    if (q.val >= maxq.val)
                    {
                        maxp = p;
                        maxq = q;
                    }
                    p = q;
                    q = q.next;
                }
                maxp.next = maxq.next;
                maxq.next = root2.next;
                root2.next = maxq;
                p = root1;
                q = root1.next;
                maxp = root1;
                maxq = root1.next;
            }

            return root2.next;
        }
    }
    public class ListNode
    {
        public int val;
        public ListNode next;
        public ListNode(int x) { val = x; }
    }
    public class TreeNode
    {
        public int val;
        public TreeNode left;
        public TreeNode right;
        public TreeNode(int x) { val = x; }
    }
}
